---
layout: post
title: 动态规划学习
category: algorithm
tags: [dynamic programming]
---
#概述

动态规划(dynamic programming)是一种通过组合子问题的解来解决整个问题的方法，此处的 programming 指的是规划而不是计算机程序设计。另一种与之相似的算法设计思路是分治法，分治法是将问题划分成一些独立的子问题，递归地求解各子问题，然后合并子问题的解来得到原问题的解。在某些特定的情况下，各个子问题不是独立的情况，会包含公共的子子问题。此时使用分治法会造成一些子问题被重复计算的情况，因此效率较低。动态规划对每个公共子问题都只计算一次，将其结果保存在表中，从而避免每次遇到各个子问题时重新计算。

动态规划通常用于*最优化*问题。此类问题一般有多个可行解，每种解只有一个值，而我们需要从中找出一种具有最优的值(如最大值或最小值)的解。这样的解被称为该问题的*一个*最优解(可能存在多个取得最优值的解)。

动态规划算法的设计可分为如下四个步骤：

1. 描述最优解的结构;
2. 递归定义最优解的值;
3. 按自底向上的方式计算最优解的值;
4. 由计算出的结果构造一个最优解。

<!-- excerpt -->

前三步构成一个问题的动态规划解的基础。第四步来求取最优解的值。在第三步中往往需要记录一些附加信息来方便构造最优解。

下面先以一个例子(来自《算法导论》)来说明以上的设计步骤，然后再来详细阐述动态规划算法的设计思路、适用情形和设计过程中要注意的问题，最后给出我个人的一点总结。

#实例(矩阵链乘法)

##问题描述

给定由 *n* 个要相乘的矩阵构成的序列(链)<A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>*n*</sub>>，要计算它们的乘积 A<sub>1</sub>A<sub>2</sub>...A<sub>*n*</sub>。由于矩阵的乘法满足结合率，因此选择矩阵序列中两两相乘的顺序可以得到相同的最终结果。一般我们可以采用加括号的方式来表示两两相乘的优先级。以 *n* = 4 为例，有如下5种相乘顺序：

{:.post-image}
(A<sub>1</sub>(A<sub>2</sub>(A<sub>3</sub>A<sub>4</sub>)))，<br/>
(A<sub>1</sub>((A<sub>2</sub>A<sub>3</sub>)A<sub>4</sub>))，<br/>
((A<sub>1</sub>A<sub>2</sub>)(A<sub>3</sub>A<sub>4</sub>))，<br/>
((A<sub>1</sub>(A<sub>2</sub>A<sub>3</sub>))A<sub>4</sub>)，<br/>
(((A<sub>1</sub>A<sub>2</sub>)A<sub>3</sub>)A<sub>4</sub>)。

虽然结果相同，不同的相乘次序带来的计算量是有差别的。两个矩阵相乘的计算量是和矩阵的行列数相关的，另外由矩阵乘法的定义，能够相乘的两个矩阵，前者的列数应等于后者的行数(两矩阵相容)，假设两个矩阵的维度分别为 L×M 和 M×N，矩阵相乘的过程可表示如下：

{% assign lang = 'c' %}
{% capture codeblock %}for (i = 0; i < L; i++) {
    for (j = 0; j < N; j++) {
        c[i][j] = 0;
        for (k = 0; k < M; k++) {
            c[i][j] += a[i][k] * b[k][j];
        }
    }
}
{% endcapture %}
{% include AH/print_code %}

由此可见计算矩阵 c 的时间由以上计算过程中的标量乘法的计算次数决定，为 LMN ，这也是衡量整个矩阵链乘法的计算次序是否最优的标准。我们再来从一个简单的例子来看， 假设矩阵 A<sub>1</sub>，A<sub>2</sub>，A<sub>3</sub> 分别为 20×200，200×5，5×40 。若先计算 A<sub>1</sub>A<sub>2</sub> 再乘以 A<sub>3</sub>，则标量乘法的计算次数为 20×200×5 + 20×5×40 = 24 000；若先计算 A<sub>2</sub>A<sub>3</sub> 再用 A<sub>1</sub> 乘以前两者的乘积，则标量乘法的计算次数为 200×5×40 + 20×200×40 = 200 000。很明显后者的计算量要比前者大出许多，此时第一种计算次序即为我们要求的矩阵链<A<sub>1</sub>，A<sub>2</sub>，A<sub>3</sub>>相乘的最优次序。

综合上面的讨论，*矩阵链乘法问题*可表述如下：给定由 *n* 个矩阵构成的一个链<A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>*n*</sub>>，矩阵 A<sub>*i*</sub>的维数为 *p*<sub>*i-1*</sub>×*p*<sub>*i*</sub> (i = 1,2,...,*n*)，对乘积 A<sub>1</sub>A<sub>2</sub>...A<sub>*n*</sub> 以一种最小化标量乘法次数的方式加全部括号。

##设计动态规划算法

对于这个问题，我们首先会想到的自然是穷举所有的加括号可能。当只有1个矩阵的时候无需计算，因此标量乘法的计算次数为0,当有2个及以上数目个矩阵时，矩阵乘积为两个全部加括号的矩阵子乘积的乘积，这两个子乘积的分裂可能发生在矩阵链中的任何一处，因此总的计算次数需要把每种情况的次数相加。假设 *P(n)* 表示一串 *n* 个矩阵可能的加括号方案数，可得递归关系如下：

{:.post-image}
![image]({{BASE_PATH}}/assets/posts/images/2014-06-22-formula-1.png)

用替换法可以证明该递归式的解为 &Omega;(2<sup>*n*</sup>)，由此数量级可知穷举不是一个有效的方法。下面用动态规划的方法来分析。

**1. 描述最优解的结构**

动态规划算法的第一步就是要寻找最优的子结构。在此例中就是要找到最优的加全部括号的结构。我们用 A<sub>*i..j*</sub> 来表示矩阵链 A<sub>*i*</sub> A<sub>*i+1*</sub> ... A<sub>*j*</sub> 相乘。对于某一个 *k* 值(*i* &le; *k* < *j*)，要计算 A<sub>*i..j*</sub> ，即首先分别计算出 A<sub>*i..k*</sub> 和 A<sub>*k+1..j*</sub>,再将两者相乘。因此加全部括号的代价即为 A<sub>*i..k*</sub> 和 A<sub>*k+1..j*</sub> 的代价之和再加上两者相乘的代价。

这个问题的最优子结构如下。假设 A<sub>*i..j*</sub> 的一个最优加全部括号把乘积在 A<sub>*k*</sub> 和 A<sub>*k+1*</sub> 处分开，则 A<sub>*i..k*</sub> 和 A<sub>*k+1..j*</sub> 的加全部括号次序分别是各自的一个最优加全部括号次序。我们可以用反证法来证明这个是最优子结构。假设 A<sub>*i..k*</sub> 有一个代价更小的加全部括号的次序，把此种情况替换到 A<sub>*i..j*</sub> 中则会产生一种新的 A<sub>*i..j*</sub> 加全部括号的次序，由上一段落中计算乘积代价的方法可知，此时的次序使得计算代价会小于最优代价从而产生矛盾。因此上述最优子结构成立。

任意一个矩阵链乘法计算过程中都需要分割乘积，即把一个问题分割为两个子问题，寻找子问题的最优解，然后合并这些子问题的最优解，从而构造出一个矩阵链乘法的最优解。

**2. 递归定义最优解的值**

接下来根据最优子结构来递归定义一个最优解的代价。设矩阵链 A<sub>*i*</sub> A<sub>*i+1*</sub> ... A<sub>*j*</sub> 相乘的最小标量乘法计算次数(代价)为 m[*i*, *j*]，此处 1 &le; *i* &le; *j* &le; *n*。则对于整个问题， A<sub>*1..n*</sub> 的最小代价为 m[*1*, *n*]。

我们来递归定义 m[*i*, *j*]。当 *i* = *j* 时，即只有一个矩阵 A<sub>*i*</sub>，代价为 0；否则 m[*i*, *j*] 可表示为 m[*i*, *k*] 和 m[*k+1*, *j*] 之和再加上 *p*<sub>*i-1*</sub>*p*<sub>*k*</sub>*p*<sub>*j*</sub> (矩阵 A<sub>*i*</sub>的维数为 *p*<sub>*i-1*</sub>×*p*<sub>*i*</sub>)，其中 *i* &le; *k* < *j* 且 该 k 值使得 m[*i*, *k*] + m[*k+1*, *j*] + *p*<sub>*i-1*</sub>*p*<sub>*k*</sub>*p*<sub>*j*</sub> 最小。综上可得到如下的递归表达式：

{:.post-image}
![image]({{BASE_PATH}}/assets/posts/images/2014-06-22-formula-2.png)

**3. 按自底向上的方式计算最优解的值**

根据上面的递归公式，我们可以很容易写出一个递归的算法来求解矩阵链 A<sub>*i*</sub> A<sub>*i+1*</sub> ... A<sub>*j*</sub> 相乘的最小代价 m[*1*, *n*]。但稍作分析就可以知道，此时的计算量和穷举法类似，也是指数级别的。原问题的子问题数目明明很有限，这是为什么呢？如果我们把递归算法产生的递归树话出来，会发现很多分支中会包含相同的子问题，大量的重复计算造成了递归算法的效率低下。子问题有重叠这一性质是判断能否使用动态规划算法的标志，另一个标志是具有最有子结构，后面会具体分析。

我们可以结合递归公式，执行动态规划算法的第三个步骤，按自底向上的方式计算最优解的值。我们用表格 m[n][n] 来保存计算得到的 m[*i*, *j*] 值 (1 &le; *i* &le; *j* &le; *n*)，从而避免重复计算。另外用表格 path[n][n] 来记录每一个子问题的最优解 m[*i*, *j*] 所取的 k 值 (1 &le; *i* &le; *k* < *j* &le; *n*)。表格 path 相当于记录了最优解的“路径”，在计算完最优代价后可以方便的构造一个最优解。

计算最优代价的算法实现如下，其中数组 l 即为矩阵的维数值 {*p<sub>0</sub>*, *p<sub>1</sub>*, ... , *p<sub>n-1</sub>*, *p<sub>n</sub>*,}：

{% assign lang = 'c' %}
{% capture codeblock %}void matrix_chain_order(unsigned int l[], unsigned int m[N][N],
    int path[N][N])
{
    int i, j, dist, k;
    unsigned int temp = 0;
            
    for (i = 0; i < N; i++) {
        m[i][i] = 0;
        path[i][i] = i;
    }

    for (dist = 1; dist < N; dist++) {
        for (i = 0; i < N - dist; i++) {
            j = i + dist;
            m[i][j] = MAX;
            for (k = i; k < j; k++) {
                temp = m[i][k] + m[k + 1][j] +l[i] * l[k + 1] * l[j + 1];
                if (temp < m[i][j]) {
                    m[i][j] = temp;
                    path[i][j] = k;
                }
            }
        }
    }
}
{% endcapture %}
{% include AH/print_code %}

由递归公式的特点，每一次 m[*i*, *j*] 的计算都会依赖于 i、j 距离更小的 m[*i*, *j*] 值。当 i、j 相等时，  m[*i*, *j*] = 0 ；不等时，我们通过变量 dist 逐渐增加 i、j间的距离由 1 到 N-1，循环的求解出了所有的  m[*i*, *j*] 值。该算法的运行时间为 O(*n*<sup>3</sup>) ，比指数级的递归算法效率要高出很多。

**4. 由计算出的结果构造一个最优解**

通过上述计算过程中记录的 path 数组，可以方便的构造一个最优解。

{% assign lang = 'c' %}
{% capture codeblock %}void print_optimal_parens(unsigned int m[N][N], int path[N][N],
    int i, int j)
{
    if (i == j) {
        printf("A%d", i);
        return;
    }
    printf("(");
    print_optimal_parens(m, path, i, path[i][j]);
    print_optimal_parens(m, path, path[i][j] + 1, j);
    printf(")");
}
{% endcapture %}
{% include AH/print_code %}

假设 N 为 6，各矩阵维数的数组 l = {30, 35, 15, 5, 10, 20, 25}，则计算出来的最优代价 m[*1*, *6*] = 15125，打印的最优解加括号方式为 ((A0(A1A2))((A3A4)A5)) 。

#动态规划基础

通过上述例子我们完整的分析了是如何用动态规划的算法来求解问题的。下面来介绍采用动态规划方法的最优化问题的两个要素：最优子结构和重叠子问题。

**最优子结构**

用动态规划的方法来求解最优解问题的时候，第一步就是描述最优解的结构。如果一个问题的最优解中包含了子问题的最优解，则该问题具有最优子结构，此时动态规划就可能适用于解决该问题(有时贪心策略有可能也适用)。在上述矩阵链乘法的例子中， *A<sub>i</sub>A<sub>i+1</sub>...A<sub>j-1</sub>A<sub>j</sub>* 的一个最优加全部括号的解把乘积在 *A<sub>k</sub>* 和 *A<sub>k+1</sub>* 处分裂，从而包含了子问题 *A<sub>i</sub>A<sub>i+1</sub>...A<sub>k</sub>* 和 *A<sub>k+1</sub>A<sub>k+2</sub>...A<sub>j</sub>* 的加全部括号的最优解。因此具有最优子结构。

在寻找最优子结构时，有一个普遍的模式：

1. 问题的解可以是做一个选择。例如矩阵链乘法的例子中，需要选择一个位于 i 和 j 之间的 下标 k 值来将相乘的过程在此处断开。每做一次这样的选择，就会得到一个或多个待解决的子问题。
2. 假设对一个给定的问题，已知某种选择可带来最优解，不必关心如何确定这个选择，只用假定它是已知的。
3. 在已知这个选择后，要确定哪些子问题会随之发生，以及怎样最好地来描述所得到的子问题空间。
4. 证明最优子结构。往往可以采用上述例子中用到的反证方法。通过假设有子问题的更优解来替换原子问题的解来推出矛盾，从而得证。

子问题的空间一定要尽量保持简单，在必要时来进行扩充。在[最大和路径]()的例子中，子问题每做一次选择只会产生一个新的具有同样结构的子问题。而在上述矩阵链乘法的例子中，我们首先可以假设子问题是形如 *A<sub>1</sub>A<sub>2</sub>...A<sub>j</sub>* 的矩阵乘积。如上述分析，总会存在一个 k 值使得一个最优加全部括号的解把乘积在 *A<sub>k</sub>* 和 *A<sub>k+1</sub>* 处分裂，从而产生了子问题 *A<sub>1</sub>A<sub>2</sub>...A<sub>k</sub>* 和 *A<sub>k+1</sub>A<sub>k+2</sub>...A<sub>j</sub>* ，此时  *A<sub>k+1</sub>A<sub>k+2</sub>...A<sub>j</sub>* 显然就不符合事先定义的子问题空间形式。因此这个问题需要允许子问题在两端变化，即 i 和 j 在子问题 *A<sub>i</sub>A<sub>i+1</sub>...A<sub>j</sub>* 中可以变化。

最优子结构在问题域中以两种方式变化：

1. 一个问题的最优解中使用了几个子问题。
2. 在决定一个最优解中使用哪些子问题时有多少个选择。

例如矩阵链乘法的问题中，一个问题的最优解中使用了2个子问题，在决定一个最优解中使用哪些子问题时有 i-j 个选择（即 k 值的可选数目）。从这两种变化方式中也能得到一个动态规划算法的运行时间依赖的两个因素：子问题的总数目以及每个子问题的选择数目。还是上述矩阵链乘法的例子， 总共有 &Theta;(*n*<sup>2</sup>) 个子问题，每个子问题至多有 *n* - 1 个选择，因此执行时间为 O(*n*<sup>3</sup>) 。

动态规划是以自底向上的方式来利用最优子结构，也就是先找到子问题的最优解，然后再通过子问题的最优解来找到该问题的最优解，如此向上。另外有一种[贪心策略]()的算法也利用了最优子结构，不过它是以自顶向下的方式，贪心策略中会先作出当时情况下的最优选择，然后再通过选择来求解相应得到的子问题。动态规划中是先确定子问题的最优解再由此来作出选择。

在判断一个问题能否用动态规划算法求解时，首先就是要确定最优子结构，此时一定要严格证明，否则不能使用动态规划算法。例如在一个无权有向图中，如果要求解两个结点之间的最短简单路径，可以证明其具有最优子结构，可通过上述反证法来证明。将问题稍微变一下，求解两个结点之间的最长简单路径，咋看是一样的情形，但其实并不具备最优子结构。

{:.post-image}
![image]({{BASE_PATH}}/assets/posts/images/2014-06-22-graph.png)

以上图中的无权有向图为例，设结点 q 到 t 的最长简单路径为 p(*q*, *t*)，直观上很快可以得出是 q->r->s->t 。假设该问题具有最优子结构，任意选取 q 到 t 的最长简单路径中的一个结点，以 r 为例，
则 p(*q*, *t*) 中应当包含 q 到 r 的最长简单路径和 r 到 t 的最长简单路径。即有 p(*q*, *r*) = q->r 。而事实上我们也能很直观得出 p(*q*, *r*) = q->t->s->r，从而推出矛盾。因此我们可知无权有向图中，两个结点之间的最长简单路径并不具备最优子结构。这是因为该问题中的各个子问题不是独立的，同一问题中一个子问题的解会影响到其他子问题的解。而求最短简单路径时子问题是相互独立的，同样矩阵链乘法中每次分出来的两个子链互不相交，也是独立的。

**重叠子问题**

重叠子问题是一个问题适用于动态规划算法求解的第二个要素。有重叠子问题，即用来解决原问题的递归算法中会反复地求解一些同样的子问题。动态规划的算法就是充分利用了这个条件，我们可以保存计算过的子问题的最优解，使得每个自问及只会被计算一次，从而减少了整个问题求解的运行时间。假设没有重叠子问题，每一次递归总在产生新的子问题，这样保存每个子问题的解就没有了意义，因为每个子问题只会遇到一次，无法减少问题求解的运行时间。

#补充

在用动态规划算法求解问题时，我们往往会在保存每个子问题的最优解的同时，也保存下每一次所作的选择(例如矩阵链乘法例子中的 path 表，保存每一次的 k 值)。这样可以帮助方便地重构出一个最优解的选择“路径”。

总之，我个人对动态规划算法的理解就是分析出问题求解的递归关系，然后通过保存子问题的解来减小问题求解的时间复杂度。能够用动态规划算法求解的问题需要满足具有**最优子结构**和**重叠子问题**两个条件。在后面的学习中还需要通过更多的练习来加强对动态规划算法的理解。